#!/bin/bash
#
# create all necessary environments
#

# list of env to find/intialise
fed_envs=(network node researcher)

# detect how the file is run
([[ -n $ZSH_EVAL_CONTEXT && $ZSH_EVAL_CONTEXT =~ :file$ ]] ||
 [[ -n $KSH_VERSION && $(cd "$(dirname -- "$0")" &&
    printf '%s' "${PWD%/}/")$(basename -- "$0") != "${.sh.file}" ]] ||
 [[ -n $BASH_VERSION ]] && (return 0 2>/dev/null)) && sourced=1 || sourced=0

[[ "${sourced}" == "1" ]] && echo "This file MUST NOT be sourced" && return

# activate conda
c=$(which conda)
if [ -z "$c" ]
then
    echo "Please install conda first !!!"
    exit 1
fi
eval "$(conda shell.bash hook)"

# ---------------
# ** functions **
# ---------------

usage() {
    #
    # print usage
    #
    echo "\
Usage: ${0##*/} [-n] [-c] [-x]

  -h, --help            this help
  -n, --dry-run         do nothing, just print what the script will do
  -c, --clean           remove environments before reinstallating it
  -x, --experimental    (optional) on MacOSX, install (yet experimental) environments
                        from *-macosx.yaml files
"
}

bad_usage () {
    echo "\
ERROR: $*
"
    usage
    exit 1
}

function clean_environment() {

    echo "=== Cleaning conda environment: $1"

    if [ $DRYRUN -eq 1 ]
    then
        echo conda remove --name $1 --all --yes
    else
        conda remove --name $1 --all --yes
    fi
}

function activate_environment() {
    #update conda environment after installing modules with
    # pip may result into inconsistencies

    base=$basedir/envs/development/conda/$1

    file="${base}.yaml"
    if [ $EXPERIMENTAL -eq 1 ]
    then
        if [ -f "${base}-macosx.yaml" ]
        then
            file="${base}-macosx.yaml"
        fi
    fi

    echo "=== Installing/Updating conda environment from: ${file##*/}"

    if [ $DRYRUN -eq 1 ]
    then
        echo conda env update --file "$file"
    else
        conda env update --file "$file" 2>/dev/null
    fi

}

function check_environment() {
    #
    # simple check that environement is OK

    echo "=== Checking import of ML packages with python"

    if [ $DRYRUN -eq 1 ]
    then
        echo "python -c 'import torch; import torchvision; import sklearn; import monai; import tensorboard'"
        return 0
    fi

    conda activate fedbiomed-researcher
    echo "python -c 'import torch; import torchvision; import sklearn; import monai; import tensorboard'"
    check=$(python -c 'import torch; import torchvision; import sklearn; import monai; import tensorboard' 2>/dev/null )

    status=$?
    if [ $status -eq 0 ]
    then
        echo "=== Installation seems OK"
    else
        echo "=== Installation seems broken: unable to load some ML packages"
    fi
    conda deactivate
    return $status
}

#
# find the directory containing all sources
#
basedir=$(cd $(dirname $0)/.. || exit ; pwd)
cd $basedir || exit 1

EXPERIMENTAL=0
DRYRUN=0
CLEAN=0
# decode arguments
while (($# > 0)); do
    case $1 in
        -h|--help )
            usage
            exit 0
            ;;
        -c | --clean )
            CLEAN=1
            ;;
        -x | --experimental )
            EXPERIMENTAL=1
            ;;
        -n | --dry-run)
            # do nothing
            DRYRUN=1
            ;;
        -* )
            bad_usage "unknown option: $1"
            ;;
        * )
            bad_usage "no extra parameter allowed: $1"
            ;;
    esac
    shift
done

# verify macOSX for -x flag
if [ $EXPERIMENTAL -eq 1 ]
then
    case $(uname) in
        Darwin )
        # this is OK, -x flag is for macOSX only
        ;;
        * )
            bad_usage "-x flag should only be used for macOSX"
            ;;
    esac
fi

if [ $CLEAN -eq 1 ]
then
    # clean all envs
    conda deactivate

    for i in ${fed_envs[@]}
    do
        clean_environment fedbiomed-$i
    done
fi

# configure/update all conda environements
for i in ${fed_envs[@]}
do
    activate_environment fedbiomed-$i
    conda deactivate
done

# check if environment is OK
check_environment
exit $?
