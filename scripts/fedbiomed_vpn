#!/usr/bin/env bash
#
# wrapper to all vpn containers commands
#
#

# detect how the file is run
([[ -n $ZSH_EVAL_CONTEXT && $ZSH_EVAL_CONTEXT =~ :file$ ]] ||
 [[ -n $KSH_VERSION && $(cd "$(dirname -- "$0")" &&
    printf '%s' "${PWD%/}/")$(basename -- "$0") != "${.sh.file}" ]] ||
 [[ -n $BASH_VERSION ]] && (return 0 2>/dev/null)) && sourced=1 || sourced=0

[[ "${sourced}" == "1" ]] && echo "This file MUST NOT be sourced" && return

# main variables
# --------------
ALL_VPN_CONTAINERS=( vpnserver mqtt restful researcher node )
#ALL_VPN_CONTAINERS=( vpnserver mqtt restful researcher node )

# all functions
# -------------
usage() {
    #
    # print usage
    #
    echo "\
Usage: ${0##*/} build     [-c|--clean] [-g|--gpu] [CONTAINER..]
       ${0##*/} clean
       ${0##*/} configure                         [CONTAINER..]
       ${0##*/} start     [-m|--model-approval]   [CONTAINER..]
       ${0##*/} status
       ${0##*/} stop

Build/configure/run/stop docker containers for VPN support
(cannot build / configure / start / stop at same time)

[CONTAINER..] is a list of containers to configure/build/run.
This list may contain: vpnserver, mqtt, restful, node

 build       build all containers

       Optional with build:

       -c|--clean  clean environments first
       -g|--gpu    build docker containers with GPU support

 clean       clean everything
             (can also be invoked with build option)

 configure   generate configuration files

 start       start all components
 status      give information on running containers
 stop        stop  all components

       Optional with start:

       -m|--model-approval  enforce model approval in config files
"
}

check_prerequisite() {
    #
    # verify that every needed commands are installed
    commands=( docker docker-compose )

    ERROR=0
    for i in ${commands[@]}
    do
        status=$(which $i)
        [[ -z "$status" ]] && { echo "ERROR: command not found: $i"; ERROR=1; }
    done
    [[ $ERROR -eq 1 ]] && { echo "Please install needed commands before running this script." ; exit 1; }
}


internal_find_my_ip() {

    algo=$1
    # heuristically test some commands to find my "external" IP

    case $1 in
        1)
            # linux/unixes
            _IP=$(hostname -I 2>/dev/null | sed -e 's:\ .*$::')
            ;;
        2)
            # linux again using ip command
            _IP=$(ip -brief address 2>/dev/null | grep UP | head -1 | awk '{print $3}' | sed -e 's:/.*::')
            ;;
        3)
            _IP=$(ip route get 1.2.3.4 2>/dev/null | head -1 | awk '{print $7}')
            ;;
        4)
            # other cases using ifconfig command
            _IP=$(ifconfig eth0 2> /dev/null| grep 'inet '| awk '{print $2}')
            ;;
        5)
            _IP=$(ifconfig en0 2> /dev/null| grep 'inet '| awk '{print $2}')
            ;;
        6)
            # check also wireless
            _IP=$(ifconfig wlan0 2> /dev/null| grep 'inet '| awk '{print $2}')
            ;;
        #
        # you may add more heuristics here
        #
        *|'')
            # always true, even if not the best choice
            _IP="127.0.0.1"
            ;;
    esac

    # verify that the result is an IPv4 adress
    _IP=$(echo $_IP | egrep '([0-9]{1,3}[\.]){3}[0-9]{1,3}')

    echo $_IP
}

find_my_ip() {

    for i in {1..100}
    do
        IP=$(internal_find_my_ip $i)
        [[ ! -z "$IP" ]] && { echo $IP ; return ; }
    done

    case $IP in
        127.*)
            echo "WARNING: vpnserver will use the localhost IP adress."
            echo "         vpnserver may not work properly"
        ;;
    esac
    # just in case (never happends but I am paranoid)
    return "127.0.0.1"
}

containers_stop() {
    echo "** Stopping docker VPN components"
    cd "$basedir/envs/vpn/docker"
    docker-compose stop
}

containers_clean() {
    echo "** Cleaning"

    cd "$basedir/envs/vpn/docker"

    containers_stop

    # specific to vpnserver
    /bin/rm -fr ./vpnserver/run_mounts/config/config_peers 2> /dev/null
    /bin/rm -fr ./vpnserver/run_mounts/config/ip_assign    2> /dev/null
    /bin/rm -fr ./vpnserver/run_mounts/config/wireguard    2> /dev/null

    # specific to restful
    /bin/rm -f  ./restful/run_mounts/app/db.sqlite3   2> /dev/null

    # specific to node
    /bin/rm -rf ./node/run_mounts/data/* 2> /dev/null
    /bin/rm -rf ./node/run_mounts/etc/*  2> /dev/null
    /bin/rm -rf ./node/run_mounts/var/*  2> /dev/null

    # specific to researcher
    /bin/rm -rf ./researcher/run_mounts/data/*     2> /dev/null
    /bin/rm -rf ./researcher/run_mounts/etc/*      2> /dev/null
    /bin/rm -rf ./researcher/run_mounts/samples/*  2> /dev/null
    /bin/rm -rf ./researcher/run_mounts/runs/*     2> /dev/null
    /bin/rm -rf ./researcher/run_mounts/var/*      2> /dev/null

    #
    for i in base basenode gui
    do
        docker-compose rm -sf $i
        docker image rm -f fedbiomed/vpn-$i
    done

    for i in ${ALL_VPN_CONTAINERS[@]}
    do
        docker-compose rm -sf $i
        docker image rm -f fedbiomed/vpn-$i
        /bin/rm -rf ./$i/run_mounts/config/wireguard 2> /dev/null
        git checkout $i/run_mounts/config/config.env
    done

    #
    docker image prune -f

}

containers_status() {
    echo "** Checking docker VPN images & VPN access"
    cd "$basedir/envs/vpn/docker"

    ERROR=0
    echo -n "- running containers -> "
    status=$(docker ps | grep fedbiomed/vpn- | wc -l)

    if [ $status -eq ${#ALL_VPN_CONTAINERS[@]} ]; then
        echo "OK"
    else
        echo "BROKEN"
        ERROR=1
    fi

    if [ $ERROR -eq 1 ]; then
        echo "ERROR: at least one of the requested docker container is not running"
        for i in ${ALL_VPN_CONTAINERS[@]}
        do
            status=$(docker ps | grep fedbiomed/vpn-$i)
            [[ -z "$status" ]] && { echo "- container $i not running"; }
        done
        return
    fi

    # ping inside the wg vpn
    for i in ${ALL_VPN_CONTAINERS[@]}
    do
        echo -n "- pinging VPN server from container $i -> "
        ping=$(docker-compose exec ${i} ping -n -c 3 -W 1 10.220.0.1 2>/dev/null | cat -v)

        status=$(echo $ping|grep seq=)
        if [ -z "$status" ]; then
            echo "BROKEN"
            ERROR=1
        else
            echo "OK"
        fi
    done

    if [ $ERROR -eq 1 ]; then
        echo "Cannot ping using VPN adresses inside docker containers"
        echo "You must check what is going on."
    fi
}

containers_build() {
    echo "** Building docker VPN images"
    cd "$basedir/envs/vpn/docker"

    echo "- building base components"
    CONTAINER_UID=$(id -u) CONTAINER_GID=$(id -g) CONTAINER_USER=$(id -un) CONTAINER_GROUP=$(id -gn) docker-compose build base
    CONTAINER_UID=$(id -u) CONTAINER_GID=$(id -g) CONTAINER_USER=$(id -un) CONTAINER_GROUP=$(id -gn) docker-compose build basenode

    for i in ${ALL_VPN_CONTAINERS[@]}
    do
        echo "- building $i container"
        CONTAINER_UID=$(id -u) CONTAINER_GID=$(id -g) CONTAINER_USER=$(id -un) CONTAINER_GROUP=$(id -gn) docker-compose build $i
    done
}


containers_configure() {
    echo "** Generating VPN/Wireguards keys"
    cd "$basedir/envs/vpn/docker"

    # replace IP in VPN main config file
    CONFIG="$basedir/envs/vpn/docker/vpnserver/run_mounts/config/config.env"
    IP=$(find_my_ip)

    git checkout $CONFIG
    sed -i -XXX "s:replace_with.myserver.mydomain:$IP:" $CONFIG && /bin/rm ${CONFIG}-XXX

    # start vpn server to generate config files
    docker-compose up -d vpnserver

    # mqtt configuration file
    docker-compose exec vpnserver python ./vpn/bin/configure_peer.py genconf management mqtt
    /bin/rm -fr ./mqtt/run_mounts/config/wireguard    2> /dev/null
    sed -i -XXX "s:replace_with.myserver.mydomain:$IP:" ./vpnserver/run_mounts/config/config_peers/management/mqtt/config.env
    /bin/rm ./vpnserver/run_mounts/config/config_peers/management/mqtt/config.env-XXX
    /bin/cp ./vpnserver/run_mounts/config/config_peers/management/mqtt/config.env ./mqtt/run_mounts/config/config.env

    # restful config file
    docker-compose exec vpnserver python ./vpn/bin/configure_peer.py genconf management restful
    /bin/rm -fr ./restful/run_mounts/config/wireguard    2> /dev/null
    sed -i -XXX "s:replace_with.myserver.mydomain:$IP:" ./vpnserver/run_mounts/config/config_peers/management/restful/config.env
    /bin/rm ./vpnserver/run_mounts/config/config_peers/management/restful/config.env-XXX
    /bin/cp ./vpnserver/run_mounts/config/config_peers/management/restful/config.env ./restful/run_mounts/config/config.env

    # researcher config file
    docker-compose exec vpnserver python ./vpn/bin/configure_peer.py genconf researcher researcher1
    /bin/rm -fr ./researcher/run_mounts/config/wireguard    2> /dev/null
    sed -i -XXX "s:replace_with.myserver.mydomain:$IP:" ./vpnserver/run_mounts/config/config_peers/researcher/researcher1/config.env
    /bin/rm ./vpnserver/run_mounts/config/config_peers/researcher/researcher1/config.env-XXX
    /bin/cp ./vpnserver/run_mounts/config/config_peers/researcher/researcher1/config.env ./researcher/run_mounts/config/config.env

    # node config files
    docker-compose exec vpnserver python ./vpn/bin/configure_peer.py genconf node node1
    /bin/rm -fr ./node/run_mounts/config/wireguard    2> /dev/null
    sed -i -XXX "s:replace_with.myserver.mydomain:$IP:" ./vpnserver/run_mounts/config/config_peers/node/node1/config.env
    /bin/rm ./vpnserver/run_mounts/config/config_peers/node/node1/config.env-XXX
    /bin/cp ./vpnserver/run_mounts/config/config_peers/node/node1/config.env node/run_mounts/config/config.env

    #
    containers_stop
}

containers_start() {
    echo "** Starting docker VPN components"

    cd "$basedir/envs/vpn/docker"

    # verify IP in config file
    CONFIG="$basedir/envs/vpn/docker/vpnserver/run_mounts/config/config.env"
    IP=$(find_my_ip)

    ip_in_file=$(grep "^VPN_SERVER_PUBLIC_ADDR=$IP$" $CONFIG)
    if [ -z "$ip_in_file" ]; then
        echo "WARNING: external IP adress has changed since last configuration"
        echo "You may need to run:  ${0##*/} configure"
        exit 1
    fi

    # start servers
    for i in ${ALL_VPN_CONTAINERS[@]}
    do
        docker-compose up -d $i
    done

    # propagate wiregard keys
    pubkey=$(docker-compose exec mqtt wg show wg0 public-key | tr -d '\r')
    docker-compose exec vpnserver python ./vpn/bin/configure_peer.py add management mqtt $pubkey

    pubkey=$(docker-compose exec restful wg show wg0 public-key | tr -d '\r')
    docker-compose exec vpnserver python ./vpn/bin/configure_peer.py add management restful $pubkey

    pubkey=$(docker-compose exec node wg show wg0 public-key | tr -d '\r')
    docker-compose exec vpnserver python ./vpn/bin/configure_peer.py add node node1 $pubkey

    pubkey=$(docker-compose exec researcher wg show wg0 public-key | tr -d '\r')
    docker-compose exec vpnserver python ./vpn/bin/configure_peer.py add researcher researcher1 $pubkey

    sleep 1 # sometimes the container volumes are not up to date immediately
    containers_status
}

# main
# ----

# detect topdir
basedir=$(cd $(dirname $0)/.. || exit ; pwd)
cd $basedir || exit

#
CLEAN=0
BUILD=0
CONFIGURE=0
START=0
STOP=0
NODE_NUMBER=1
GPU=0
APPROVAL=0

#
check_prerequisite

# must provide at least an option
if [ $# -eq 0 ]; then
    echo "must provide an option"

    usage
    exit 1
fi

# arguments decoding
while (($# > 0)); do
    case $1 in

        build)
            BUILD=1
            shift
            while (($# > 0)); do
                case $1 in
                    -c|--clean) CLEAN=1 ;;
                    -g|--gpu)   GPU=1 ;;
                    -h|--help)  usage ; exit 0 ;;
                    *)
                        echo "unknown or incompatible arguments"
                        usage
                        exit 1
                        ;;
                esac
                shift
            done
            ;;

        clean)
            CLEAN=1
            shift
            while (($# > 0)); do
                case $1 in
                    -h|--help)          usage ; exit 0 ;;
                    *)
                        echo "unknown or incompatible arguments"
                        usage
                        exit 1
                        ;;
                esac
                shift
            done
            ;;

        config*)
            CONFIGURE=1
            shift
            while (($# > 0)); do
                case $1 in
                    -h|--help)          usage ; exit 0 ;;
                    -c|--clean) CLEAN=1 ;;
                    *)
                        echo "unknown or incompatible arguments"
                        usage
                        exit 1
                        ;;
                esac
                shift
            done
            ;;


        start)
            START=1
            shift
            while (($# > 0)); do
                case $1 in
                    -h|--help)          usage ; exit 0 ;;
                    -m|--model-approval) APPROVAL=1 ;;
                    *)
                        echo "unknown or incompatible arguments"
                        usage
                        exit 1
                        ;;
                esac
                shift
            done
            ;;

        stop)
            STOP=1
            shift
            while (($# > 0)); do
                case $1 in
                    -h|--help)          usage ; exit 0 ;;
                    -m|--model-approval) APPROVAL=1 ;;
                    *)
                        echo "unknown or incompatible arguments"
                        usage
                        exit 1
                        ;;
                esac
                shift
            done
            ;;

        status)
            STATUS=1
            shift
            while (($# > 0)); do
                case $1 in
                    -h|--help)          usage ; exit 0 ;;
                    *)
                        echo "unknown or incompatible arguments"
                        usage
                        exit 1
                        ;;
                esac
                shift
            done
            ;;
        *)
            echo "unknown or incompatible option: $1"
            usage
            exit 1
            ;;
    esac
    shift
done


# start doing something usefull
# -----------------------------
[[ $CLEAN -eq 1 ]]     && { containers_clean; }
[[ $BUILD -eq 1 ]]     && { containers_build; }
[[ $CONFIGURE -eq 1 ]] && { containers_configure; }
[[ $START -eq 1 ]]     && { containers_start; }
[[ $STOP -eq 1 ]]      && { containers_stop; }
[[ $STATUS -eq 1 ]]    && { containers_status; }

exit 0
