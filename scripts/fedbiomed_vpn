#!/usr/bin/env bash
#
# wrapper to all vpn containers commands
#
#

# detect how the file is run
([[ -n $ZSH_EVAL_CONTEXT && $ZSH_EVAL_CONTEXT =~ :file$ ]] ||
 [[ -n $KSH_VERSION && $(cd "$(dirname -- "$0")" &&
    printf '%s' "${PWD%/}/")$(basename -- "$0") != "${.sh.file}" ]] ||
 [[ -n $BASH_VERSION ]] && (return 0 2>/dev/null)) && sourced=1 || sourced=0

[[ "${sourced}" == "1" ]] && echo "This file MUST NOT be sourced" && return


# all functions
# -------------
usage() {
    #
    # print usage
    #
    echo "\
Usage: ${0##*/} build     [-c|--clean]
       ${0##*/} configure [-n number]
       ${0##*/} node      [-m|--model-approval] start|stop
       ${0##*/} server    [-m|--model-approval] start|stop

Build/configure/run docker containers for VPN support
(cannot build / configure / node / server at same time)

 build                    build all containers

     Optional with build:

     -c|--clean           clean environments first

 configure                   generate configuration files (IP and keys)

     Optional with generate:

     -n number            number of node configuration file(s) to generate
                          (1 if not provided)

 node                     start/stop a local node's docker  (already built)
 server                   start/stop local server's dockers (already built)

     Required with node/server:

     start                start the component
     stop                 stop  the component

     Optional with node/server:

     -m|--model-approval  enforce model approval in config files

"
}

internal_find_my_ip() {

    algo=$1
    # heuristically test some commands to find my "external" IP

    case $1 in
        1)
            # linux/unixes
            _IP=$(hostname -I 2>/dev/null | sed -e 's:\ .*$::')
            ;;
        2)
            # linux again using ip command
            _IP=$(ip -brief address 2>/dev/null | grep UP | head -1 | awk '{print $3}' | sed -e 's:/.*::')
            ;;
        3)
            _IP=$(ip route get 1.2.3.4 2>/dev/null | head -1 | awk '{print $7}')
            ;;
        4)
            # other cases using ifconfig command
            _IP=$(ifconfig eth0 2> /dev/null| grep 'inet '| awk '{print $2}')
            ;;
        5)
            _IP=$(ifconfig en0 2> /dev/null| grep 'inet '| awk '{print $2}')
            ;;
        6)
            # check also wireless
            _IP=$(ifconfig wlan0 2> /dev/null| grep 'inet '| awk '{print $2}')
            ;;
        #
        # you may add more heuristics here
        #
        *|'')
            # always true, even if not the best choice
            _IP="127.0.0.1"
            ;;
    esac

    # verify that the result is an IPv4 adress
    _IP=$(echo $_IP | egrep '([0-9]{1,3}[\.]){3}[0-9]{1,3}')

    echo $_IP
}

find_my_ip() {

    for i in {1..100}
    do
        IP=$(internal_find_my_ip $i)
        [[ ! -z "$IP" ]] && { echo $IP ; return ; }
    done

    case $IP in
        127.*)
            echo "WARNING: vpnserver will use the localhost IP adress."
            echo "         vpnserver may not work properly"
        ;;
    esac
    # just in case (never happends but I am paranoid)
    return "127.0.0.1"
}

container_clean() {
    echo "** CLEANING"
}

container_build() {
    echo "** BUILDING"

    cd "$basedir/envs/vpn/docker"

    echo "- building base component"
    CONTAINER_UID=$(id -u) CONTAINER_GID=$(id -g) CONTAINER_USER=$(id -un) CONTAINER_GROUP=$(id -gn) docker-compose build base

    echo "- building vpnserver"
    CONTAINER_UID=$(id -u) CONTAINER_GID=$(id -g) CONTAINER_USER=$(id -un) CONTAINER_GROUP=$(id -gn) docker-compose build vpnserver

}

configure() {
    echo "** GENERATING KEYS"
    IP=$(find_my_ip)

    cd "$basedir/envs/vpn/docker"
    docker-compose up -d vpnserver

    /bin/rm -fr ./vpnserver/run_mounts/config/config_peers 2> /dev/null
    sleep 1 # sometimes the container volumes are not up to date immediately

    docker-compose exec vpnserver python ./vpn/bin/configure_peer.py genconf management mqtt
    sed -i -XXX "s:replace_with.myserver.mydomain:$IP:" ./vpnserver/run_mounts/config/config_peers/management/mqtt/config.env
    /bin/rm ./vpnserver/run_mounts/config/config_peers/management/mqtt/config.env-XXX

    docker-compose exec vpnserver python ./vpn/bin/configure_peer.py genconf management restful
    sed -i -XXX "s:replace_with.myserver.mydomain:$IP:" ./vpnserver/run_mounts/config/config_peers/management/restful/config.env
    /bin/rm ./vpnserver/run_mounts/config/config_peers/management/restful/config.env-XXX

    docker-compose exec vpnserver python ./vpn/bin/configure_peer.py genconf researcher researcher1
    sed -i -XXX "s:replace_with.myserver.mydomain:$IP:" ./vpnserver/run_mounts/config/config_peers/researcher/researcher1/config.env
    /bin/rm ./vpnserver/run_mounts/config/config_peers/researcher/researcher1/config.env-XXX

    for (( i = 1; i <= NODE_NUMBER; ++i ))
    do
        n="node${i}"
        docker-compose exec vpnserver python ./vpn/bin/configure_peer.py genconf node ${n}
        sed -i -XXX "s:replace_with.myserver.mydomain:$IP:" ./vpnserver/run_mounts/config/config_peers/node/${n}/config.env
        /bin/rm ./vpnserver/run_mounts/config/config_peers/node/${n}/config.env-XXX
    done

    CONFIG="$basedir/envs/vpn/docker/vpnserver/run_mounts/config/config.env"
    IP=$(find_my_ip)

    git checkout $CONFIG
    sed -i -XXX "s:replace_with.myserver.mydomain:$IP:" $CONFIG && /bin/rm ${CONFIG}-XXX
}

start_node() {
    echo "** STARTING nodes"
}

start_servers() {
    echo "** STARTING server"

    cd "$basedir/envs/vpn/docker"

    # substitute @IP in config file
    CONFIG="$basedir/envs/vpn/docker/vpnserver/run_mounts/config/config.env"
    IP=$(find_my_ip)

    ip_in_file=$(grep "^VPN_SERVER_PUBLIC_ADDR=$IP$" $CONFIG)
    if [ -z "$ip_in_file" ]; then
        echo "** external IP adress has changed since last configuration"
        echo "You may need to run:  ${0##*/} configure"
        exit 1
    fi
    docker-compose up -d vpnserver
}

# main
# ----

# detect topdir
basedir=$(cd $(dirname $0)/.. || exit ; pwd)
cd $basedir || exit

#
CLEAN=0
BUILD=0
CONFIGURE=0
NODE=0
SERVER=0
APPROVAL=0
START=0
STOP=0
NODE_NUMBER=1

ERROR=0

# must provide at least an option
if [ $# -eq 0 ]; then
    echo "must provide an option"

    usage
    exit 1
fi

# arguments decoding
while (($# > 0)); do
    case $1 in

        build)
            BUILD=1
            shift
            while (($# > 0)); do
                case $1 in
                    -c|--clean)         CLEAN=1 ;;
                    -h|--help)          usage ; exit 0 ;;
                    *)
                        echo "unknown or incompatible arguments"
                        usage
                        exit 1
                        ;;
                esac
                shift
            done
            ;;

        config*)
            CONFIGURE=1
            shift
            while (($# > 0)); do
                case $1 in
                    -h|--help)          usage ; exit 0 ;;
                    -n)
                        NODE_NUMBER=$2
                        shift
                        NODE_NUMBER=$(echo $NODE_NUMBER | egrep -e '^[1-9][0-9]*$')
                        if [ -z "$NODE_NUMBER" ]; then
                            echo "node number must be a positive integer"
                            usage
                            exit 1
                        fi
                        ;;
                    *)
                        echo "unknown or incompatible arguments"
                        usage
                        exit 1
                        ;;
                esac
                shift
            done
            ;;

        node|server)

            if [ $1 = "node" ]; then
                NODE=1
            fi
            if [ $1 = "server" ]; then
                SERVER=1
            fi

            shift
            while (($# > 0)); do
                case $1 in
                start) START=1 ;;
                stop)  STOP=1 ;;
                -m|--model-approval) APPROVAL=1 ;;
                *)
                    echo "unknown or incompatible option: $1"
                    usage
                    exit 1
                    ;;
                esac
                shift
            done

            # concatenate start/stop into ACTION
            ACTION=""
            if [ $STOP -eq 1 ]; then
                if [ $START -eq 0 ]; then
                    ACTION=stop
                else
                    echo "ERROR: do I stay or do I go ? (start and stop both requested)"
                    usage
                    exit 1
                fi
            fi
            if [ $START -eq 1 ]; then
                ACTION=start
            fi
            if [ -z $ACTION ]; then
                echo "ERROR: must provide start or stop"
                usage
                exit 1
            fi

            ;;
        *)
            echo "unknown or incompatible option: $1"
            usage
            exit 1
            ;;
    esac
    shift
done

# start doing something usefull
# -----------------------------
if [ $CLEAN -eq 1 ]; then
    container_clean
fi

if [ $BUILD -eq 1 ]; then
    container_build
fi

if [ $CONFIGURE -eq 1 ]; then
    configure
fi

if [ $NODE -eq 1 ]; then
    start_node
fi

if [ $SERVER -eq 1 ]; then
    start_servers
fi
