#!/usr/bin/env bash
#
# wrapper to all vpn containers commands
#
#

# detect how the file is run
([[ -n $ZSH_EVAL_CONTEXT && $ZSH_EVAL_CONTEXT =~ :file$ ]] ||
 [[ -n $KSH_VERSION && $(cd "$(dirname -- "$0")" &&
    printf '%s' "${PWD%/}/")$(basename -- "$0") != "${.sh.file}" ]] ||
 [[ -n $BASH_VERSION ]] && (return 0 2>/dev/null)) && sourced=1 || sourced=0

[[ "${sourced}" == "1" ]] && echo "This file MUST NOT be sourced" && return


# all functions
# -------------
usage() {
    #
    # print usage
    #
    echo "\
Usage: ${0##*/} build  [-c|--clean] [-g|--generate-keys]
       ${0##*/} server [-m|--model-approval] start|stop
       ${0##*/} node   [-m|--model-approval] start|stop

Build/configure/run docker containers for VPN support
( build / node / server flags are incompatibles )


 build                    build all containers

     Optional with --build:

     -c|--clean           clean environments first
     -g|--generate_keys   generate new keys for components

 server                   start/stop local server's dockers (already built)
 node                     start/stop a local node's docker  (already built)

     Required with --node/--server:

     start                start the component
     stop                 stop  the component

     Optional with --node/--server:

     -m|--model-approval  enforce model approval in config files

"
}

internal_find_my_ip() {

    algo=$1
    # heuristically test some commands to find my "external" IP

    case $1 in
        1)
            # linux/unixes
            _IP=$(hostname -I 2>/dev/null | sed -e 's:\ .*$::')
            ;;
        2)
            # linux again using ip command
            _IP=$(ip -brief address 2>/dev/null | grep UP | head -1 | awk '{print $3}' | sed -e 's:/.*::')
            ;;
        3)
            _IP=$(ip route get 1.2.3.4 2>/dev/null | head -1 | awk '{print $7}')
            ;;
        4)
            # other cases using ifconfig command
            _IP=$(ifconfig eth0 2> /dev/null| grep 'inet '| awk '{print $2}')
            ;;
        5)
            _IP=$(ifconfig en0 2> /dev/null| grep 'inet '| awk '{print $2}')
            ;;
        6)
            # check also wireless
            _IP=$(ifconfig wlan0 2> /dev/null| grep 'inet '| awk '{print $2}')
            ;;
        #
        # you may add more heuristics here
        #
        *|'')
            # always true, even if not the best choice
            _IP="127.0.0.1"
            ;;
    esac

    # verify that the result is an IPv4 adress
    _IP=$(echo $_IP | egrep '([0-9]{1,3}[\.]){3}[0-9]{1,3}')

    echo $_IP
}

find_my_ip() {

    for i in {1..100}
    do
        IP=$(internal_find_my_ip $i)
        [[ ! -z "$IP" ]] && { echo $IP ; return ; }
    done

    case $IP in
        127.*)
            echo "WARNING: vpnserver will use the localhost IP adress."
            echo "         vpnserver may not work properly"
        ;;
    esac
    # just in case (never happends but I am paranoid)
    return "127.0.0.1"
}

container_clean() {
    echo "CLEANING"
}

container_build() {
    echo "BUILD PHASE"

    cd "$basedir/envs/vpn/docker"

    echo "- building base component"
    CONTAINER_UID=$(id -u) CONTAINER_GID=$(id -g) CONTAINER_USER=$(id -un) CONTAINER_GROUP=$(id -gn) docker-compose build base

    echo "- building vpnserver"
    CONTAINER_UID=$(id -u) CONTAINER_GID=$(id -g) CONTAINER_USER=$(id -un) CONTAINER_GROUP=$(id -gn) docker-compose build vpnserver

}

keys_generate() {
    echo "GENERATING KEYS"
}

start_node() {
    echo "STARTING node"
}

start_servers() {
    echo "STARTING server"

    cd "$basedir/envs/vpn/docker"

    # substitute @IP in config file
    CONFIG="$basedir/envs/vpn/docker/vpnserver/run_mounts/config/config.env"
    IP=$(find_my_ip)

    git checkout $CONFIG
    sed -i -XXX "s:replace_with.myserver.mydomain:$IP:" $CONFIG && /bin/rm ${CONFIG}-XXX

    docker-compose up -d vpnserver
}

# main
# ----

# detect topdir
basedir=$(cd $(dirname $0)/.. || exit ; pwd)
cd $basedir || exit

#
CLEAN=0
BUILD=0
GENERATE=0
NODE=0
SERVER=0
APPROVAL=0
START=0
STOP=0

ERROR=0

# must provide at least an option
if [ $# -eq 0 ]; then
    echo "must provide an option"

    usage
    exit 1
fi

# arguments decoding
while (($# > 0)); do
    case $1 in

        build)
            BUILD=1
            shift
            while (($# > 0)); do
                case $1 in
                    -c|--clean)         CLEAN=1 ;;
                    -g|--generate_keys) GENERATE=1 ;;
                    -h|--help)          usage ; exit 0 ;;
                    *)
                        echo "unknown or incompatible arguments"
                        usage
                        exit 1
                        ;;
                esac
                shift
            done
            ;;

        node|server)

            if [ $1 = "node" ]; then
                NODE=1
            fi
            if [ $1 = "server" ]; then
                SERVER=1
            fi

            shift
            while (($# > 0)); do
                case $1 in
                start)
                    START=1
                    ;;
                stop)
                    STOP=1
                    ;;
                -m|--model-approval)
                    APPROVAL=1
                    ;;
                *)
                    echo "unknown or incompatible option: $1"
                    usage
                    exit 1
                    ;;
                esac
                shift
            done
            ;;
        *)
            echo "unknown or incompatible option: $1"
            usage
            exit 1
            ;;
    esac
    shift
done

# concatenate start/stop into ACTION
ACTION=""
if [ $STOP -eq 1 ]; then
    if [ $START -eq 0 ]; then
        ACTION=stop
    else
        echo "ERROR: do I stay or do I go ? (start and stop both requested)"
        usage
        exit 1
    fi
fi
if [ $START -eq 1 ]; then
    ACTION=start
fi
if [ -z $ACTION ]; then
    echo "ERROR: must provide start or stop"
    usage
    exit 1
fi

# start doing something usefull
# -----------------------------
if [ $CLEAN -eq 1 ]; then
    container_clean
fi

if [ $BUILD -eq 1 ]; then
    container_build
fi

if [ $GENERATE -eq 1 ]; then
    keys_generate
fi

if [ $NODE -eq 1 ]; then
    start_node
fi

if [ $SERVER -eq 1 ]; then
    start_servers
fi
